Field descriptions
==================

1 Signal name (symbolic)
------------------------
  Static name of the signal. To be used in output for legend if field #2
  isn't given. If neither #1 not #2 is given, signal name will be named
  Signal_<nr>, where <nr> is the line-number of the sample-description
  file.

2 Signal name from file
-----------------------
  Signal name is contained in this file. Name is expected to be the only
  content of this file. If string is longer than the length of #1, name
  will be truncated from beginning of text and length characters long.

3 Data-file name
----------------
  Signal data is fetched from this file

4 Sampling operation
--------------------
  An integer value corresponding a bit-field defining data-file mode of
  operation or other details about how sampling should be done.

  Note, setting these may also alter the complete sample behaviour from
  rate-monotonic (default behaviour) to event-driven. Not setting this
  defaults to a safe but slow rate-monotonic behaviour where each file is
  constantly opened and closed. Note that some files require not having this
  set default. For example files that can block would block the whole sample
  if not marked "can block".


4.1 Bits
----------
    1: OPENCLOSE: File is constantly opened and closed. This is a costly but
       safe operation (as it will always work). It's also the default file
       operation mode if #4 is empty. For some files, like log-files that
       might have been renamed or sysfs files that can dynamically exist
       and disappear, it's a necessary setting.

    2: CANBLOCK: Set this indicates file can block. If file is not at the same time
       en event driver (see TRIGGER below), file will be inspected if it
       has something to deliver before read. CANBLOCK implies OPENCLOSE
       being unset. Typical files in this category would be:
       * Clear text drivers
       * /proc/kmsg
       * Named pipes. This is very useful when you need another process to
		 help interpret/filter something which sampler has no way of
		 interpreting itself. For example reading events like this:
               mkfifo /data/local/tmp/logcat_e.txt;
               logcat -b events -v threadtime > /data/local/tmp/logcat_e.txt

    3: TRIGGER: Updates of this file triggers a complete sample. Updates can
       come in two forms:

       A) Files that CANBLOCK. When new data releases the block for one
          signal, it will drive the event for the complete sample (i.e. all
          other signals too).
       B) Files that are TIMED, I.e. that can't block, but which support
          st_mtime in `struct stat`. In this case, rate-monotonic has to
          poll the state, but only if it's modified since last sample, will
          it drive an event.

       Special notes:
         Consideration has to be taken into account for signals *not*
         updated since last sample, when events are driving samples, see
         field #9.

         In the physical world, two event's can't occur at exactly the
         same time. One event always occurs before another even ever so
         slightly. In the digital world, due to time-resolution and
         other practical limitations, they can. If more than one TRIGGER
         can drive an event, #9 allows output of the other, there will be
         no possibility to distinguish which is cause and which is
         effect. Even if #9 doesn't allow output for non-updated signals
         (assuming updates can be determined), two TRIGGERs can still
         both contain data, in which case it's a limitation of the kernel
         and scheduler. Ideally, If TRIGGER is set, each sample will
         contain only one field with data, the rest would be empty. This
         is a case that will rarely happen, especially as samples will
         commonly contain files from sysfs, there st_mtime isn't
         supported.

         There might be other types of events concurrently driving samples
         not specified by signal descriptions. For example strace, ftrace
         waitid (possibly filtered) events.

    4: TIMED: File has support for st_mtime. File will not be read if stat
       shows it's has not been updated. If not combined with TRIGGER,
       output always falls back on #9 (TBD - not implemented yet)

    5: NO_REWIND: File that has OPENCLOSE unset can stay open between events
       to optimize sample harvest. However, some files might never the less
       need to be rewind (i.e. lseek(fd, 0 SEEK_SET)) before willing to give
       updated data. This applies to most files under sysfs but not
       /sys/kernel/debug. IOW it's a safe setting for most files to let
       NO_REWIND be unset if OPENCLOSE is also set, except for debugfs.

       Technical background: Rewinding with lseek is used as a way to detect
       if a file still exists for a certain inode (NO_SIG detection) which
       is of particular interest for files under sysfs depending on the
       plug-in HW framework but could also affect user-files who's
       existence depends on netlink.

    8-11 THREAD_OPTION:
       This is a field of several bits representing a value (0-15), i.e. the
       third nibble counting from right in HEX. Value represent various
       sampling alternatives concerning how to sample. There is no strict
       definition concerning higher vs. lower values, but as a rule of
       thumb: lower values mean less threading optimizing, higher means more
       threading optimization. I.e. a low value will thread every single
       detail (work-task), whereas a higher try various strategies not to
       thread.

       Values:

         0:  THREAD_ALL: Always thread everything. This is the default, but
             it might be costly.

         1:  NO_SUB_THREADS: Try to optimize not to thread subsignals. Some
             signals have many sub-signal definitions. For example: each
             CPU-counter in file /proc/sys have 10 sub-signals. On a 8-core
             target that means 9x10=90 threads. This creates a non
             negligible and hard to motivate temporal overhead on Linux
             (depending on the task type). This FOPS-bit tries to optimize
             signal-harvest to use only one thread per signal. It is a
             recommendation only and it's not the engine that decides. The
             work-tasks do this. It should work as intended for most
             work-types, but it's always a safe option as it will always
             fall back to THREAD_ALL if work-task don't have built in
             support for this optimizing option.

        2:  NEVER_SUB_THREAD:  This is a harder optimization variant of
            NO_SUB_THREADS. This option ignores whether a work-task has
            built-in support for this optimization not to thread. It tells
            the _engine_ not to thread, i.e. the work-task never gets a
            chance to decide. The benefit is that threads need not be
            started to find out (which has a certain start/set-up cost) but
            the drawback is that it's not guaranteed to work. I.e. the user
            needs to know what works and what doesn't. If uncertain, don't
            use this mode (or try and find out).

        3-14: TBD

        15: SINGLE_THREADING: (RESERVED. Not implemented yet - TBD). All
            sampling overall is done in a single threaded. This mode of
            operation is primarily a check-mode as the fully single-thread mode
            affects SAMPLER overall, and these modes define how sampling
            should operate.  There might be several ways of single threading
            however and this bit might be used to let the engine know if it
            can group together this signal in a bunch of work-tasks or not.

   12-20 PRIORITY:
       This is a field of several bits representing a value (0-15), i.e. the
       forth nibble counting from right in HEX. Value represent priority for
       the signal. I.e. in which order to harvest a sample. This is useful
       if there are interdependencies between signals which post-process
       tools require to be able to compose virtual signal (i.e. signals
       which don't exist "as is" in the system but are reconstructed on host
       side).

       Be very careful when deploying this feature without the aid of
       management tools (sampler-manager). If uncertain, leave unset. If
       deployed, the thread running this task (i.e. collecting the signal)
       will leave default scheduling principle (i.e.  SCHED_NORM on Linux)
       and enter SCHED_FIFO/SCHED_RR. First of all: this requires root
       privileges which you might not have. Second: Be
       aware of that all SCHED_FIFO/SCHED_RR are run *before* SCHED_NORM no
       matter priority level (SHED_NORM is what most processes run under,
       including any window manager or console/terminal). I.e. "priority"
       has a completely different meaning in the various domains and if if
       sampler is run to fast it might starve the target so badly it first
       of all affect the measurement, or in worst case disable you from even
       killing a rouge sampling process. There are ways to moderate this
	   risk, see the following article for leads:
	   http://lwn.net/Articles/296419/

       PRIORITY is a feature which requires threading, i.e. THREAD_OPTION no
       higher than 2. It decouples otherwise necessity to specify signals in
       a certain order in sampler-editor. I.e. user who change definition of
       virtual signals need not bother how to schedule the harvest,
       sampler-editor will in each chain of dependencies figure that out and
       automatically set the signal with the longest chain of dependencies
       the highest priority. Note that there could be several independent
       chains running concurrently which is why the number of priority
       levels are relatively few. I.e. the longest chain of dependency is 16
       levels deep.

   31: ALWAYS: assert file or signal existence. I.e. framework assumes there
	   always exists a file and in that file a valid content according to
	   the selection methods (i.e. line and value regular expressions if
	   used). Operation fail in runtime if above conditions are not
	   fulfilled, which should occur immediately on start. This mode is
	   recommended initially when defining new signals and if not certain on
	   selection regex:s or if OPENCLOSE is not set for files in sysfs that
	   can come and go depending on the HW plug-in framework.
	   cpu-up/cpu-down affected files would be a typical example when you
	   would like to have this enabled.  If uncertain, always set if
	   OPENCLOSE is unset.

5 Regex identifying line to parse.
-----------------------------------
  Can be NULL, which means don't scan, use complete file as data (usually
  one liner data-files which is quite common in sysfs)

  Regex follow extended regex format. If escape characters are needed, no
  need to escape the escape (reg-exp text is read as is). Regex can contain
  sub-expressions, but no special care is taken about these. Match applies
  to the complete line or not at all.

  Scanning file continues until first match our until the match number
  given in #6.. If regex would match more than one line, only the first
  line or the one specified is considered for #7.

6 Line count match
------------------
  When parsing more complex files, #5 can give multiple hits. Consider for
  example /proc/cpuinfo. This field, if given, must contain an integer
  specifying which hit counting from top for which further data extraction
  by #7 applies to. If left empty it defaults to the first hit, unless both
  #5 and #6 are left empty, in  which has it has the special meaning that
  data is not considered for extraction line by line, but instead the whole
  file is considered. In which case regex anchors '^' and '$' loose their
  meaning, but is a quite common case in sysfs were a most files contain
  only value entry (i.e. #5-#8 are empty). There could however exist cases
  when parsing complex files where everything has to be done by one regex
  only. One such case would be parsing accumulative log-files.

7 Signal regex
---------------
  NULL means don't parse, use complete line as is.

  Regex follow extended regex format. If escape characters are needed, no
  need to escape the escape (reg-exp text is read as is). Regex can
  contain sub-expressions, in which case #7 is needed.

8 Sub-match index
-----------------
  Sub-match index, or list of index, represents data. If 0 or NULL,
  complete match is used, in which case #6 is pointless as it means the
  same as using the whole line and #5 alone defines which.

  Having any value here without any signal regex defined, or if any index
  is larger than the largest sub-expression number in #6 would be an
  error.

  NOTE: Errors are not detected until runtime! It's a good idea to test
  your regex strings against known patterns before running them on target.

  If #6 contain sub-expressions this field contain which sub-expression
  contain data. Field is either an integer number, or a list of integer
  numbers.

  If field contain more than one sub-expression which with data, output
  will contain all subexpressions mentioned here, in the same order as
  mentioned an separated by the normal delimiter used as if it would be
  several separate signals. Signal-name outputted in the legend will be
  suffixed with an index corresponding.

  For a more specif signal name, two separate signals need be defined
  parsing the same file and same line need be defined.

9 On no update (NUCE)
---------------------------
  This is a code (i.e. value, not bit-field) specifying what to output if
  during run no update has occurred for this signal

  0: Nothing. Output is an EMPTY field. Unfortunately this will confuse
     feedgnuplot and drivegnuplot, therefor please avoid.

  1: Last value (default). This setting is useful for events representing
     states.

  2: Per signal defined "dead-signal" value. A specific value can be
     defined per each main signal. This is useful if many signals come and
     go and one wants to distinguish one dead signal from the other. Note
     that this is a string. I.e. output can be both numerical or textual. It
     currently defaults to the name of the signal suffixed with "_DEAD"

  3: Output per sample pre-set "signal dead-value". It defaults to a define
     used in the code and can be overloaded during build-time. This is
     Oscilloscope analogy for a dead or unconnected signal. By combining
     this with #A below, one can make sampler generate magic values useful
     for plotting discontinuous graphs (needs post-processing and usage off
     --dump flag for feedgnuplot).

  As no updates can be an indication of error in either the framework or
  the signal definition, two methods for setting pre-set values can
  be used.

 A: Output pre-set signal value via command line. This is a value passed
    on command line for each signal.

 B: Output pre-set sample value. This is a hard-coded value defined during
    build time using -DSMPL_FALLBACK_VAL=<val>. If not set, it defaults to
    0xC0DEDEAD.

